### 2 分发饼干
```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        // 按照顺序排列
        sort(g.begin(), g.end());
        sort(s.begin(), s.end()); 
        int res = 0;
        // 从小到大满足孩子的胃口
        for(int i  = 0, j = 0; i < g.size(); i++) {  
            // 找到第一个能满足孩子胃口的饼干
            while(j < s.size() && s[j] < g[i]) j++;
            // 如果能满足
            if(j < s.size()) {
                j++;
                res++;
            }
            // 如果当前孩子胃口无法满足，后面胃口更大的孩子更无法满足
            else break;
        }
        return res;
    }
};
```

### 3. 摆动序列
```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        // 去掉重复元素
        nums.erase(unique(nums.begin(), nums.end());
        int res = 0;
        // 查找中间有多少个波峰，波谷（极值）
        for(int i = 1; i + 1 < nums.size(); i++) {
            int a = nums[i - 1], b = nums[i], c = nums[i + 1];
            if(a < b && b > c || a > b && b < c) res++;
        }
        return res;
    }
};
```

### 4. 最大子序和
```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int res = nums[0], sum = nums[0];
        for(int i = 1; i < nums.size(); i++) { 
            sum = max(0, sum);
            sum += nums[i];
            res = max(res, sum);
        }
        return res;
    }
};
```

### 6. 买卖股票的最佳时机II
```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int res = nums[0], sum = nums[0];
        for(int i = 1; i < nums.size(); i++) { 
            sum = max(0, sum);
            sum += nums[i];
            res = max(res, sum);
        }
        return res;
    }
};
```

### 7.跳跃游戏
```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int res = nums[0], sum = nums[0];
        for(int i = 1; i < nums.size(); i++) { 
            sum = max(0, sum);
            sum += nums[i];
            res = max(res, sum);
        }
        return res;
    }
};
```
### 45.跳跃游戏II
```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        // 目前能跳到的最远位置
        int max_far = 0;
        // 跳跃次数 
        int step = 0; 
        // 上次跳跃可达范围的右边界（下次的最右起跳点）
         int end = 0; 
        for(int i = 0; i < nums.size() - 1; i++) {
            max_far = max(max_far, i + nums[i]);
            if(i == end) {
                end = max_far;
                step++;
            }
        }
        return step;
    }
};
```
### 13.柠檬水找零
```c++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int five = 0, ten = 0;
        for(auto x : bills) {
            // 不找0
            if(x == 5) {
                five++;
            } 
            // 找5元，入账5元
            else if(x == 10) {
                if(five == 0)  return false;
                five--;
                ten++;
            }
            // 找5元，入账15元
            else if(x == 20) {
                if(ten && five) ten--,five--;
                else if(five >= 3) five -= 3;
                else return false; 
            }
        } 
        return true;
    }
};
```
### 406.根据身高重建队列
```c++
//  版本1，时间复杂度>0(n * n)
class Solution {
public:
    // 排队规则：按照高度从高到低排序，高度相等，则按前面人数由小到大排序
    static bool cmp(vector<int> a, vector<int> b) {
        if(a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), cmp); 
        vector<vector<int>> que;
        for(int i = 0; i < people.size(); i++) {
            // 前面比他高的人数就是他当前插入的位置
            int k = people[i][1];
            // 插入数组中的位置，
            que.insert(que.begin() + k, people[i]);
        }
        return que;
    }
};
```
```c++
// 版本二
class Solution {
public:
    // 排队规则：按照高度从高到低排序，高度相等，则按前面人数由小到大排序
    static bool cmp(vector<int> a, vector<int> b) {
        if(a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), cmp); 
        // 换成链表，链表的插入时间复杂度为0(1)
        list<vector<int>> que;
        for(int i = 0; i < people.size(); i++) {
            // 前面比他高的人数就是他当前插入的位置
            int k = people[i][1];
            // 插入数组中的位置，
            auto it = que.begin();
            for(int j = 0; j < k; j++) it++;
            que.insert(it, people[i]);
        }
        return vector<vector<int>>(que.begin(), que.end());
    }
};
```

### 452. 用最少数量的箭引爆气球
```c++
class Solution {
public:
    static bool cmp(vector<int> a, vector<int> b) {
        return a[1] < b[1];
    }
    int findMinArrowShots(vector<vector<int>>& points) {
        // 按区间右端点位置从小到大排序
        sort(points.begin(), points.end(), cmp); 
        // 初始化射击次数为1， 
        int res = 1, r = points[0][1];
        for(int i = 1; i < points.size(); i++) {
            // 用上次区间右端点与当前区间左端点对比，是否由交集，如果没有交集，则要增加射击次数
            if(points[i][0] > r) {
                r = points[i][1];
                res++;
            }
        }
        return res;
    }
};
```
### 435.无重叠区间
```c++
class Solution {
public: 
    static bool cmp(vector<int> &a, vector<int> &b) {
        return a[1] < b[1];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if(intervals.empty()) return 0;
        // 按照右端点从小到大排序
        sort(intervals.begin(), intervals.end(), cmp);
        int res = 1, r = intervals[0][1];
        // 找到没有交集区间的个数的最大值
        for(int i = 1; i < intervals.size(); i++) { 
            // 如果当前左端点与上个区间的右端点没有重叠
            if(intervals[i][0] >= r) {
                res++;
                r = intervals[i][1];
            }
        }
        return intervals.size() - res;
    }
};
```